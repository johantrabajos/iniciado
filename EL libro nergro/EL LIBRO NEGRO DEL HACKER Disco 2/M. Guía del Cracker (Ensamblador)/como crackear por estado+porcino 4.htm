<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0044)http://users.vr9.com/wktrelz/tktk/eporc4.htm -->
<HTML><HEAD><TITLE>WKT -- COMO CRACKEAR POR ESTADO+PORCINO --</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>

<META content="MSHTML 5.00.2014.210" name=GENERATOR></HEAD>
<BODY aLink=#efff2f bgColor=#000000 link=#c00061 text=#ffffff vLink=#00670e>
<CENTER><BR>
<TABLE border=2>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#ffcc33 vAlign=center><B><FONT color=#ffffff 
      face=Arial size=+2>COMO CRAKEAR POR ESTADO+PORCINO</FONT> 
  </B></TD></TR></TBODY></TABLE></CENTER><BR><BR>
<CENTER>
<TABLE border=2>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#000000 vAlign=center><FONT color=#ffcc33 
      face=Arial size=+3>CAPÍTULO IV. Haciendo de Cerrajeros</FONT><BR><FONT 
      color=#ffcc33 size=+1><U>-Generadores de Llaves (KeyGen)-<BR>Revival 2.1 
      </U></FONT></TD></TR></TBODY></TABLE></CENTER><BR>
<P align=center><FONT color=#ffcc33 size=+1><U>Mayo 1998</U></FONT><BR><BR></P>
<CENTER>
<TABLE border=0>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#ffcc33 vAlign=center><FONT color=#000000 
      size=+2><B>Indice</B></FONT> </TD></TR>
  <TR>
    <TD align=left vAlign=center><FONT color=#ffcc33 face=Arial 
      size=3><B><U>INTRODUCCIÓN</B></U></FONT> <BR><BR><FONT color=#ffcc33 
      face=Arial size=3><B><U>Generadores de Llaves</B></U></FONT> <BR><BR><FONT 
      color=#ffcc33 face=Arial size=3><B><U>¿Es posible crear un Generador de 
      Llaves?</B></U></FONT> <BR><BR><FONT color=#ffcc33 face=Arial 
      size=3><B><U>¿Pos mu bien, pero que necesito pa hacer un Generador de 
      Llaves?</B></U></FONT> <BR><BR><FONT color=#ffcc33 face=Arial 
      size=3><B><U>¿Merece la pena hacer un Generador?</B></U></FONT> 
      <BR><BR><FONT color=#ffcc33 face=Arial size=3><B><U>Generador de Llaves 
      para REVIVAL 2.1:</B></U></FONT> <BR><BR><FONT color=#ffcc33 face=Arial 
      size=3><B><U>Notas para los lectores 
</B></U></FONT></TD></TR></TBODY></TABLE></CENTER><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00>INTRODUCCIÓN</FONT></B> </P>
      <P><B>¡Saludos Familia! </B></P>
      <P><B>Aprovechando las vacas estivales me he decidido por escribir un 
      bonito Generador de Llaves (en inglés KeyGen) para un útil programa de 
      reparación de discos duros y disquetes. Como siempre un poco de Teoría 
      para que podamos entendernos. </B></P>
    <TD></TD></TR></TBODY></TABLE><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00>Generadores de Llaves.</FONT> </B></P><B>La 
      primera pregunta que responder es ¿qué carajo es un Generador de Llaves? 
      Suponed por un instante que sois unos de esos programadores perezosos y 
      cegados por el dinero que ha construido un programa protegido con un 
      número de serie. Si alguien desea registrarse debemos pagar una cifra de 
      dinero (pequeña o no) que hará engrosar nuestra cuenta. A cambio debemos 
      de enviarle un número de serie que desbloquee el programa. ¿Hasta ahora 
      todo correcto, verdad?. ¿Pero como demonios se genera un número de serie 
      diferente para cada usuario? . La respuesta es: con un Generador de 
      Llaves. <BR><BR>Existen dos tipos de Generadores de Llaves: <BR><BR>A- 
      Dependientes de los datos del cliente.<BR>B- Independientes de los datos 
      del cliente. <BR><BR>El tipo A es el más extendido, el número de serie se 
      genera a partir del nombre del cliente y el de su dirección de correo (por 
      ejemplo). Así dos usuarios tendrán números de serie diferentes, por que en 
      principio sus datos personales son diferentes.<BR><BR>El tipo B está un 
      poco en desuso, pero se siguen viendo por que son fáciles de programar 
      (recordad que los programadores son por naturaleza vagos y sin 
      imaginación).<BR>El mismo número de serie es válido para cualquier 
      cliente. En estos casos, el programador da un número diferente a los 
      clientes pardillos que compran su producto y reza para que no se lo den a 
      nadie. </B>
    <TD></TD></TR></TBODY></TABLE><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00><FONT color=#00ff00>¿Es posible crear un 
      Generador de Llaves?</FONT> </FONT></B></P><B><BR>El programa Generador de 
      Llaves está normalmente en el ordenata del programador, entonces, ¿cómo 
      demonios puede un cracker construir un Generador ?. La respuesta es 
      sencilla pero difícil (en general) de realizar.<BR>El programa debe 
      verificar que el número de serie que introducimos es válido y ésto sólo 
      puede hacerlo verificando ciertas propiedades que debe cumplir el número 
      de serie y que fueron establecidas por el Generador. <BR>¿Un poco lioso 
      verdad?, dicho de otra forma, el Generador es un codificador de números de 
      serie y en el programa sólo existe un decodificador que descifra el número 
      de serie introducido. <BR><BR>Vemos un sencillo ejemplo, suponed que 
      nuestro Generador es el 
      siguiente:<BR><BR>NúmeroSerie=(89934*4)*(nombre(5))<BR><BR>Donde nombre(5) 
      es la quinta letra del nombre del usuario. EL número 89934 es el llamado 
      número mágico, un número que es de agrado del programador (quizás el 
      número de veces que le ha su jefe le ha jodido) y que realmente es el 
      corazón del Generador <BR><BR>En el programa, para ver que el número de 
      serie es correcto se debe de verificar: (NúmeroSerie/(4 /nombre(5)) = 
      89934<BR><BR>Como podéis apreciar, lo que hay en el programa es la inversa 
      del Generador, por tanto si invertimos la inversa podemos obtener el 
      Generador de Partida. <BR><BR>No os engañéis, este es un Generador 
      sencillo, lo normal es que esté ultra enrevesao , lleno de números mágicos 
      y operaciones aritméticas exóticas.<BR><BR>Normalmente, las rutinas de 
      verificación realizan ciertas comprobaciones sobre la password de entrada. 
      Generalmente pasan a mayúsculas y buscan ciertos caracteres en ciertas 
      posiciones. En caso de no encontrarlos la password no es válida. Esto da 
      pie a un truco mu útil pa localizar di una forma directa la rutina. Pero 
      esto lo veremos más adelante. <BR></B></TD></TR>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00><FONT color=#00ff00>¿Pos mu bien, pero que 
      necesito pa hacer un Generador de Llaves?</FONT> </FONT></B></P><B>1.- Lo 
      primero es aislar el código del programa que verifica el número de serie. 
      <BR>Además del código que las funciones que son llamadas desde la rutina 
      de verificación (pa Saber que narices hacen). Normalmente las rutinas de 
      verificación hacen uso de pequeñas rutinas: convertir a 
      mayúsculas,convertir letras en números... <BR><BR>2.- Un conocimiento 
      exhaustivo, repito, exhaustivo del la rutina de verificación. <BR>Debemos 
      saber TODO lo que hace y porqué lo hace. Recordad que tenemos que invertir 
      su funcionamineto y esto no lo podemos hacer si no sabemos como funciona. 
      Este es el punto más delicado y el que consume más tiempo. Dependiendo de 
      las paranoias del programador podéis tardar horas o semanas. Se necesitan 
      conocimientos de ensamblador y de operaciones aritméticas binarias 
      <BR><BR>3.- Invertir el funcionamineto del Generador y crear con un 
      compilador, por ejemplo de C nuestro propio Generador. </B></TD></TR>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00><FONT color=#00ff00>¿Merece la pena hacer un 
      Generador?</FONT> </FONT></B></P><B>La respuesta es depende. Hacer un 
      Generador no es nada sencillo, consume mucho tiempo y habilidades. Es 
      mucho más fácil parchear la rutina de verificación para que acepte 
      cualquier cosa.<BR><BR>Pero las ventajas de crear un Generador son muy 
      importantes, primera y ante todo es que realmente se está cumpliendo con 
      la filosofía crack (ingeniería inversa) al comprender y transformar el 
      programa para que adapte a nuestras necesidades.<BR><BR>Segúnda ventaja 
      son los conocimientos que se captan sobre todo a nivel ensamblador y de 
      operaciones aritméricas con bits.<BR><BR>Tercera y no más importante la 
      satisfacción del trabajo artesano, bien hecho. Esa satisfacción que nos 
      hace seguir adelante.<BR><BR>La cuarta ventaja tiene que ver con la 
      historia del Software. Puedes "coleccionar" las protecciones de tu 
      programa favorito y ver la evolución de su software. <BR><BR>Y como quinta 
      un fin práctico, al final del proceso se obtiene un número de serie 
      válido, lo que te convierte en un usuario "legal" y problamente no tengas 
      que crakear la próxima versión. </B></TD></TR></TBODY></TABLE><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00>Generador de Llaves para REVIVAL 2.1</FONT> 
      </B></P>
      <P><B>Objetivo: REVIVAL 2.1<BR><BR>Nombre: revive21.zip<BR>Tamaño: 874.644 
      bytes<BR>Versión: 2.1<BR>Site: 
      http://uc2.unicall.be/revival/<BR>Herramientas: SoftIce,W32dasm o IDA 3.75 
      y un compilador de C.<BR>Dificultad: No mu difícil.<BR>Tiempo: 5 
      horas.<BR></B></P>
      <P><B>Este es un interesante programa que te permite recuperar ficheros 
      borrados de discos duros y disquetes que soporta FAT32 y NTFS. Tiene una 
      típica ventana de registro a partir de la cual podemos acceder 
      directamente a la rutina de verificación de la pass. Esta rutina es 
      extremadamente sencilla e independiente de los datos del usuario, por eso 
      ha sido la elegida como demostración.<BR><BR>Aconsejo desensamblar con el 
      IDA PRO 3.75(una pequeña maravilla de desensamblador). Se puede hacer con 
      el W32dasm pero el IDA nos da más información y nos ahorra trabajo. Por 
      ejemplo descubre de forma automática rutinas (_touper, isdigit...) que no 
      son reconocidas como tales por el W32dasm.<BR><BR>Bien, manos a la obra, 
      desensamblemos con el IDA.<BR><BR>¿Ya está?<BR>Bien, ahora sólo hay que 
      localizar la rutina de verificación. Empleemos un viejo truco: el 80% de 
      las rutinas de verificación intentan localizar el carácter '-' (2D en 
      hexa) o el carácter '+' (2B en hexa). <BR>No me preguntéis por qué, pero 
      lo hacen. Sólo hace falta buscar un 2Dh o un 2Bh y con un poco de suerte 
      aterrizaremos en plena rutina de verificación. Debemos buscar una 
      comprobación con 2Dh o bien 2Bh, pero como las comprobaciones pueden ser 
      de muchos tipos , sólo buscaremos la parte final de la comprobación. 
      <BR><BR>Resumiendo, buscaremos ", 2Dh" y ", 2Bh". En caso de existir 
      demasiadas ocurrencias, mejor decantarse por otro método de ataque. Al 
      final es el olfato de cracker el que te indica si estás en la ocurrencia 
      correcta o no. <BR>En este caso hay 20 ocurrencias de "2D" y 18 de "2B". 
      UFF, quizás demasiadas (de hecho es la primera ocurrencia de "2D" la 
      correcta), así que probemos un método más directo con el Softice. 
      <BR><BR>Metemos como nombre ESTADO, como campañía PORCINO y como número de 
      serie estúpido por ejemplo 1212121212. CTRL+D y le damos al botón de OK y 
      aparece una ventana de error.<BR><BR>Esta ventana se parece a un 
      messageboxexa (por su simplicidad y por el icono en forma de exclamación y 
      por el único botón que aparece). Si repetimos el mismo proceso pero 
      poniendo en el softice bpx messsageboxexa y pulsamos el botón de OK 
      ...<BR>Bingo, aparecemos en la rutina de messageboxexa. Sólo hay que 
      seguir la secuencia de llamadas hacia atrás buscando un salto que evite 
      llamar a la ventana de mensaje de error. La secuencia de pasos 
      es:<BR><BR>* Paramos en bpx messageboxexa<BR>* Pulsamos F12 para llegar a 
      la rutina padre que llamó a messageboxexa.<BR>* Aparecemos en :4313CA pero 
      por se ve ningún salto que evite la llamada a messageboxexa.<BR>* Pulsamos 
      F12 para seguir subiendo hasta la rutina padre.<BR>* Aparecemos en 
      :43145D. Pero de nuevo nada interesante.<BR>* De nuevo F12 y ....<BR>* 
      Aparecemos en :40CAAC8, esta si tiene lo que buscamos, exactamente. 
      <BR><BR><PRE>
0040AA6C		 call	 sub_40CD10 ; RUTINA DE VERIFICACIÓN
0040AA71		 add	 esp, 4
0040AA74		 test	 eax, eax
0040AA76		 jz	 short loc_40AABA; SALTA SI ERES UN MAL CRACKER.
0040AA78		 mov	 dword ptr [esi+5Ch], 1
0040AA7F		 mov	 eax, [esi+64h]
0040AA82		 push	 eax
0040AA83		 push	 offset	aName;NOMBRE.
0040AA88		 call	 sub_40AD70
0040AA8D		 add	 esp, 8
0040AA90		 mov	 eax, [esi+60h]
0040AA93		 push	 eax
0040AA94		 push	 offset	aCompany;COMPAÑÍA.
0040AA99		 call	 sub_40AD70
0040AA9E		 add	 esp, 8
0040AAA1		 mov	 eax, [edi]
0040AAA3		 push	 eax
0040AAA4		 push	 offset	aSerial;NÚMERO DE SERIE.
0040AAA9		 call	 sub_40AD70
0040AAAE		 add	 esp, 8
0040AAB1		 mov	 ecx, esi
0040AAB3		 call	 sub_42550E
0040AAB8		 jmp	 short loc_40AACF
0040AABA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0040AABA 
0040AABA loc_40AABA:				 ; CODE	XREF: sub_40AA20+56_j
0040AABA		 push	 0FFFFFFFFh
0040AABC		 push	 30h
0040AABE		 push	 0EF1Fh      ; DIRECCION DEL MENSAJE DE ERROR 
0040AAC3		 call	 sub_431413  ; VENTANA DE MESAJE DE ERROR  
0040AAC8		 mov	 ecx, esi
0040AACA		 call	 sub_425527
0040AACF 
0040AACF loc_40AACF:				 ; CODE	XREF: sub_40AA20+98_j
0040AACF		 push	 0FFFFFFFFh
0040AAD1		 mov	 ecx, edi
0040AAD3		 call	 sub_429A33
0040AAD8		 pop	 edi
0040AAD9		 pop	 esi
0040AADA		 retn	 
0040AADB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0040AADB 
0040AADB loc_40AADB:				 ; CODE	XREF: sub_40AA20+25_j
0040AADB					 ; sub_40AA20+40_j
0040AADB		 push	 0FFFFFFFFh
0040AADD		 push	 30h
0040AADF		 push	 0EF1Eh
0040AAE4		 call	 sub_431413
0040AAE9		 pop	 edi
0040AAEA		 pop	 esi
0040AAEB		 retn	 
0040AAEB sub_40AA20	 endp
</PRE><BR><BR>Fijaos en el salto en :40AA76. Si saltamos caemos en la 
      ventana de mensaje y evitamos acceder a NOMBRE,COMPAÑÍA y NÚMERO DE SERIE. 
      El salto está controlado por :40AA6C call sub_40CD10 .Que interesante, una 
      rutina que controla la ventana de mensaje de error, ¿a qué nos suena 
      ésto?. BINGO, estamos ante la rutina de verificación. <BR>Échemósle un 
      vistazo y comentémosla.<BR><BR>;Desensamblado con el IDA ;p(0) indica el 
      carácter 0 de la password. Recordad, empiezo a contar los caracteres desde 
      0.<BR><BR><PRE>0040CD10 sub_40CD10	 proc near		 ; CODE	XREF: sub_404600+98_p
0040CD10					 ; sub_40AA20+4C_p
0040CD10 
0040CD10 var_24		 = byte	ptr -24h ; 1 variable local.
0040CD10 var_20		 = word	ptr -20h ; 2 variable local.
0040CD10 var_1E		 = byte	ptr -1Eh ; 3 variable local.
0040CD10 var_1B		 = byte	ptr -1Bh ; 4 variable local.
0040CD10 arg_0		 = dword ptr  4  ; Argumento de la función que no es más que la dirección de nuestra password. 
0040CD10 
0040CD10		 sub	 esp, 24h; Ajusta la pila para reservar espacio para las varibles locales.
0040CD13		 push	 ebx; Guarda algunos registros.
0040CD14		 push	 esi
0040CD15		 mov	 esi, [esp+2Ch+arg_0]  ; esi= dirección de nuestra password.
0040CD19		 push	 edi
0040CD1A		 movsx	 eax, byte ptr [esi]   ; eax=p(0)
0040CD1D		 push	 eax
0040CD1E		 call	 _toupper              ; Pasamos a mayúsculas p(0).
0040CD23		 add	 esp, 4
0040CD26		 cmp	 eax, 52h              ; ¿ES P(0) = R?
0040CD29		 jnz	 loc_40CE7F            ; Salta a flag de error si p(0) no es R.
0040CD2F		 movsx	 eax, byte ptr [esi+1] ; eax=p(1)
0040CD33		 push	 eax
0040CD34		 call	 _toupper              ; Pasamos a mayúsculas p(1).
0040CD39		 add	 esp, 4
0040CD3C		 cmp	 eax, 56h              ; ¿ES P(1) = V?
0040CD3F		 jnz	 loc_40CE7F            ; Salta a flag de error si p(1) no es V.
0040CD45		 cmp	 byte ptr [esi+7], 2Dh ; ¿ES P(7) = '-'?
0040CD49		 jnz	 loc_40CE7F            ; Salta a flag de error si p(7) no es '-'.
0040CD4F		 push	 esi
0040CD50		 call	 ds:lstrlenA           ; Calcula el tamaño de la password.
0040CD56		 cmp	 eax, 0Fh              ; ¿Es el tamaño 15?
0040CD59		 jnz	 loc_40CE7F            ; Salta a flag de error si el tamaño no es 15    
0040CD5F		 mov	 edi, 2                ; Segundo carácter.
0040CD64 
0040CD64 loc_40CD64:				 ; CODE	XREF: sub_40CD10+6D_j
                                                          
                         ;Bucle para comprobar que son números p(2)...p(6)            
0040CD64		 movsx	 eax, byte ptr [edi+esi]; eax=p(2)
0040CD68		 push	 eax                
0040CD69		 call	 _isdigit               ; ¿es un número p(2)?
0040CD6E		 add	 esp, 4
0040CD71		 test	 eax, eax
0040CD73		 jz	 loc_40CE64             ; Salta con flag de error si p(2) no es número.
0040CD79		 inc	 edi                    ; Apuntamos al siguiente carácter.
0040CD7A		 cmp	 edi, 7                 ; ¿Hemos llegado a p(7)?
0040CD7D		 jl	 short loc_40CD64       ; Salta si no hemos llegado a p(7). 
0040CD7F		 mov	 edi, 8                 ; Octavo carácter.

			 ;Bucle para comprobar que son números p(8)...p(14)
0040CD84 
0040CD84 loc_40CD84:				 ; CODE	XREF: sub_40CD10+8D_j
0040CD84		 movsx	 eax, byte ptr [edi+esi];; eax=p(8)
0040CD88		 push	 eax
0040CD89		 call	 _isdigit        ;¿es un número p(8)?
0040CD8E		 add	 esp, 4
0040CD91		 test	 eax, eax
0040CD93		 jz	 loc_40CE6D      ; Salta con flag de error si p(8) no es número.
0040CD99		 inc	 edi             ; Apuntamos al siguiente carácter.
0040CD9A		 cmp	 edi, 0Fh        ; ¿Hemos llegado a p(15)?  
0040CD9D		 jl	 short loc_40CD84; Salta si no hemos llegado a p(15). 
0040CD9F		 mov	 ax, [esi+2]     ; ax=p(2)p(3)  
0040CDA3		 mov	 [esp+30h+var_20], ax
0040CDA8		 lea	 eax, [esp+30h+var_20]
0040CDAC		 mov	 [esp+30h+var_1E], 0
0040CDB1		 push	 eax     
0040CDB2		 call	 _atoi           ;Pasa p(2)p(3) a número. 
0040CDB7		 mov	 cx, [esi+5]     ;cx=p(5)p(6)
0040CDBB		 add	 esp, 4
0040CDBE		 mov	 [esp+30h+var_20], cx
0040CDC3		 sub	 al, 13h         ; al=p(2)p(3)-19  
0040CDC5		 lea	 ecx, [esp+30h+var_20]
0040CDC9		 mov	 [esp+30h+var_24], al
0040CDCD		 mov	 [esp+30h+var_1E], 0
0040CDD2		 push	 ecx
0040CDD3		 call	 _atoi            ;Pasa p(5)p(6) a número. 
0040CDD8		 lea	 edx, [esp+34h+var_20];
0040CDDC		 add	 esp, 4
0040CDDF		 lea	 ebx, [eax-25h]   ;ebx=p(5)p(6)-37
0040CDE2		 lea	 ecx, [esi+0Ah]   ;ecx=dirección de p(10)
0040CDE5		 push	 edx
0040CDE6		 mov	 eax, [ecx]       ;ebx=p(10)p(11)p(12)p(13)
0040CDE8		 mov	 [edx],	eax
0040CDEA		 mov	 cl, [ecx+4]      ;cl=p(14) 
0040CDED		 mov	 [edx+4], cl
0040CDF0		 mov	 [esp+34h+var_1B], 0
0040CDF5		 call	 _atoi            ;Pasa p(10)p(11)p(12)p(13)p(14) a número. 
0040CDFA		 add	 esp, 4
0040CDFD		 mov	 edi, eax
0040CDFF		 xor	 di, 5468h        ;di=p(10)p(11)p(12)p(13)p(14) XOR 21508 
0040CE04		 mov	 ax, [esi+8]      ;ax=p(8)p(9)
0040CE08		 mov	 [esp+30h+var_20], ax
0040CE0D		 lea	 eax, [esp+30h+var_20]
0040CE11		 mov	 [esp+30h+var_1E], 0
0040CE16		 movzx	 edi, di
0040CE19		 push	 eax 
0040CE1A		 call	 _atoi            ;Pasa p(8)p(9) a número. 
0040CE1F		 mov	 byte ptr [esp+34h+var_20], al
0040CE23		 add	 esp, 4
0040CE26		 xor	 eax, eax
0040CE28		 mov	 ecx, 64h
0040CE2D		 mov	 al, bl             ;al=p(5)p(6)-37
0040CE2F		 mov	 ebx, 0Ah
0040CE34		 lea	 eax, [eax+edi+3]; eax'=(p(5)p(6)-37)+(p(10)p(11)p(12)p(13)p(14) XOR 21508) + 3
0040CE38		 cdq	 
0040CE39		 idiv	 ecx             ;Divide eax'/100
0040CE3B		 mov	 cl, dl          ;cl=resto(eax'/100)
0040CE3D		 xor	 eax, eax
0040CE3F		 mov	 al, [esp+30h+var_24]
0040CE43		 lea	 eax, [eax+edi+3]; eax=(p(2)p(3)-19)+(p(10)p(11)p(12)p(13)p(14) XOR 21508) + 3
0040CE47		 cdq	 
0040CE48		 idiv	 ebx             ;Divide eax/10
0040CE4A		 sub	 dl, [esi+4]     ;dl=resto(eax/10)-p(4)
0040CE4D		 cmp	 dl, 0D0h        ;¿Es resto(eax/10) = p(4)?
0040CE50		 jnz	 short loc_40CE76;Salta a flag de error si resto(eax/10) no es p(4)
0040CE52		 cmp	 byte ptr [esp+30h+var_20], cl;¿Es resto(eax'/100) = p(8)p(9)?
0040CE56		 jnz	 short loc_40CE76;Salta a flag de error si resto(eax'/100) no es p(4)
0040CE58		 mov	 eax, 1          ; Ok todo correcto. Flag de éxito activado. 
0040CE5D		 pop	 edi
0040CE5E		 pop	 esi
0040CE5F		 pop	 ebx
0040CE60		 add	 esp, 24h
0040CE63		 retn	 
0040CE64 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0040CE64 
0040CE64 loc_40CE64:				 ; CODE	XREF: sub_40CD10+63_j
0040CE64		 xor	 eax, eax        ; Eres un mal chico.Flag de error activado.
0040CE66		 pop	 edi
0040CE67		 pop	 esi
0040CE68		 pop	 ebx
0040CE69		 add	 esp, 24h
0040CE6C		 retn	 
0040CE6D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0040CE6D 
0040CE6D loc_40CE6D:				 ; CODE	XREF: sub_40CD10+83_j
0040CE6D		 xor	 eax, eax        ; Eres un mal chico.Flag de error activado.
0040CE6F		 pop	 edi
0040CE70		 pop	 esi
0040CE71		 pop	 ebx
0040CE72		 add	 esp, 24h
0040CE75		 retn	 
0040CE76 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
</PRE><BR><BR>Antes de seguir adelante, centremonos en un par de puntos: 
      <BR><BR>- ¿Habéis descubierto los números mágicos?, sip los hay son 5468h, 
      0Ah y 64h.<BR>- Como es tradición la rutina checkea en este caso la 
      presencia del carácter '-'.<BR>Luego con un poco de paciencia, nuestra 
      búsqueda inicial hubiera tenido sus frutos.<BR>- Habéis notado la pésima 
      calidad del código. Uso innecesario de variables, instrucciones inútiles, 
      tamaño del código exagerado. Todo esto es debido a que se programó en alto 
      nivel, seguramente en C.<BR>¿Cómo quieren los programadores proteger su 
      software si es de pésima calidad?. Están directamente vendidos (salvo 
      honrosas excepciones, por supuesto.)<BR>- Si andais un poco pegaos de 
      operacones aritméticas y de ensamblador, buscad alguno<BR>de los fabulosos 
      cursos de ensamblador que hay en la Web. <PRE>Resumamos los momentos más interesantes de la rutina de verificación:

A)0040CD26		 cmp	 eax, 52h              ; ¿ES P(0) = R?
B)0040CD3C		 cmp	 eax, 56h              ; ¿ES P(1) = V?
C)0040CD45		 cmp	 byte ptr [esi+7], 2Dh ; ¿ES P(7) = '-'?
D)0040CD56		 cmp	 eax, 0Fh              ; ¿Es el tamaño 15?
E)0040CD64 		 ;Bucle para comprobar que son números p(2)...p(6)
F)0040CD84		 ;Bucle para comprobar que son números p(8)...p(14)
G)0040CDC3		 sub	 al, 13h               ; al=p(2)p(3)-19  
H)0040CDDF		 lea	 ebx, [eax-25h]        ; ebx=p(5)p(6)-37
I)0040CE34		 lea	 eax, [eax+edi+3]      ; eax'=(p(5)p(6)-37)+(p(10)p(11)p(12)p(13)p(14)                      
                                                      XOR 21508) + 3
J)0040CE3B		 mov	 cl, dl                ; cl=resto(eax'/100)
K)0040CE43		 lea	 eax, [eax+edi+3]      ; eax=(p(2)p(3)-19)+(p(10)p(11)p(12)p(13)p(14) 
                                                      XOR 21508) + 3
L)0040CE4D		 cmp	 dl, 0D0h              ;¿Es resto(eax/10) = p(4)?
M)0040CE52		 cmp	 byte ptr [esp+30h+var_20], cl;¿Es resto(eax'/100) = p(8)p(9)?.

Por A),B),C),D),E) y F) sabemos que la password debe de tener este aspecto:

	00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
        R  V  x  x  x  x  x  -  x  x  x  x  x  x  x  x  

Donde x es un número del 0 al 9.

Despues hay dos bonitas ecuaciones:


Por H),I),J) y M)

	I) p(8)p(9)=resto( (p(5)p(6)-0x25)+(p(10)p(11)p(12)p(13)p(14) XOR 21508) + 3) / 0x64)

Por G),K),L)
	II) p(4)=resto((p(2)p(3)-0x13)+(p(10)p(11)p(12)p(13)p(14) XOR 21508) + 3) / 0x0A)

</PRE>Pos ya está. Estas son las ecuaciones de la rutina de verificación, 
      ya se puede implementar nuestro propio Generador de Llaves, que no será 
      más que implementar estas dos ecuaciones. <BR>Estas dos ecuaciones 
      comprueban que la parte derecha sea igual a la parte izquierda (p(8)p(9) y 
      p(4)). Nuestro Generador calculara la parte derecha y construirá la parte 
      izquierda de forma adecuada. Se podrían simplificar un poco, pero no lo 
      haré pa no complicar el asunto.<BR><BR>Un posible Generador en C sería 
      algo así como:<BR><BR></B>
      <P></P></TD></TR>
  <TR>
    <TD align=left vAlign=top><BR>
      <P><B><FONT color=#00ff00><FONT color=#00ff00><A 
      href="http://users.vr9.com/wktrelz/tktk/eporc4code.txt">VER CODIGO FUENTE 
      DEL GENERADOR</FONT> </A></FONT></B></P>Utilizo números aleatorios 
      (random) para generar un número de serie diferente cada vez que se ejecute 
      e programa. Una última curiosidad, donde creereis que guarda nuestra pass 
      el programa. Si lanzais el La utilidad regmon (analiza todos los accesos 
      al Registro dels Sistema) con el programa, podréis apreciar que se accede 
      a "HKEY_LOCAL_MACHINE\SOFTWARE\Revival\Revival\2.0\Serial" Poco 
      imaginativo, ¿verdad?. Podéis modificar este número para evitar registraos 
      y probad Con nuevas pass. </TD></TR>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00><FONT color=#00ff00>Notas para los 
      lectores.</FONT> </FONT></B></P><B>1.- Los mensajes del tipo "Hazme el 
      crack para ....", "Dime como de crackea....", "Dime donde puedo 
      encontrar..." son automáticamente ignorados. El objetivo de estos 
      artículos es enseñar a crackear no enseñar a ser unos llorones ineptos que 
      sólo saben mendigar.<BR><BR>2.- Sólo responderé a preguntas teóricas sobre 
      cracks, indicando algunas pistas que faciliten la labor.<BR><BR>3.- 
      Narices, escribid artículos sobre los programas que crackeeis.<BR>De nada 
      sirve lo que aprendéis si no lo repartís, se os pudre en el cabeza, 
      palabra.<BR><BR>4.- Lamento no haber contestado a ciertos mails 
      interesantes. Desde aquí mis excusas.<BR><BR>5.- Si os ha servido para 
      algo mis artículos, no seáis vagos y mandad un mail indicándomelo. 
      </B><BR><BR>Mr_PinK &amp; WKT ( WHISKEY KON TEKILA ) 
      </B><BR><BR><B>Esperamos vuestras opiniones, sugerencias y ensayos en <A 
      href="mailto:estadoporcino@hotmail.com">estadoporcino@hotmail.com</A></B> 
      <BR><B>En breve analizaremos tipos de protecciones mucho más 
      interesantes.</B><BR>
      <P><B>Recordad bebed de la fuente, buscad a <FONT 
      color=#00ff00>+ORC</FONT> en la red.</B> </P></TD></TR></TBODY></TABLE><BR><BR>
<CENTER>
</BODY></HTML>
