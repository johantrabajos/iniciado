<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0044)http://users.vr9.com/wktrelz/tktk/eporc2.htm -->
<HTML><HEAD><TITLE>WKT -- COMO CRACKEAR POR ESTADO+PORCINO --</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>

<META content="MSHTML 5.00.2014.210" name=GENERATOR></HEAD>
<BODY aLink=#efff2f bgColor=#000000 link=#c00061 text=#ffffff vLink=#00670e>
<CENTER><BR>
<TABLE border=2>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#ffcc33 vAlign=center><B><FONT color=#ffffff 
      face=Arial size=+2>COMO CRAKEAR POR ESTADO+PORCINO</FONT> 
  </B></TD></TR></TBODY></TABLE></CENTER><BR><BR>
<CENTER>
<TABLE border=2>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#000000 vAlign=center><FONT color=#ffcc33 
      face=Arial size=+3>CAPÍTULO II. Diseccionando a los 
      Muertos</FONT><BR><FONT color=#ffcc33 size=+1><U>Uedit 5.0</U></FONT> 
  </TD></TR></TBODY></TABLE></CENTER><BR>
<P align=center><FONT color=#ffcc33 size=+1><U>Enero 1998</U></FONT><BR><BR></P>
<CENTER>
<TABLE border=0>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#ffcc33 vAlign=center><FONT color=#000000 
      size=+2><B>Indice</B></FONT> </TD></TR>
  <TR>
    <TD align=left vAlign=center><FONT color=#ffcc33 face=Arial 
      size=3><B><U>INTRODUCCIÓN</B></U></FONT> <BR><BR><FONT color=#ffcc33 
      face=Arial size=3><B><U>DESCENSO A LOS INFIERNOS:</B></U></FONT> <BR>- Mu 
      bien y esto pa que coño me sirve.<BR><BR><FONT color=#ffcc33 face=Arial 
      size=3><B><U>EL LISTADO MUERTO:</B></U></FONT> <BR>- Manos a a la obra. 
  </TD></TR></TBODY></TABLE></CENTER><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00>INTRODUCCIÓN</FONT></B> </P>
      <P><B>!Saludos Familia ! </B></P>
      <P><B>Empezemos este año con una de las técnicas crack más importantes "El 
      Listado muerto" o "death listing". Hasta ahora hemos visto la 
      "aproximación en vivo" o "live approaching" con el maravilloso Softice. 
      </B></P>
    <TD></TD></TR></TBODY></TABLE><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00>DESCENSO A LOS INFIERNOS.</FONT> </B></P>
      <P><B>Veamos de una vez por todas como se ejecuta una sentencia en el 
      procesador, desde el inicio hasta el final. </B></P>
      <P><B>Supongamos que estamos programando en un lenguaje de Alto Nivel (C, 
      C++, Pascal,Delphi,Visual Basic). Se llaman de Alto Nivel para 
      diferenciarlos de los lenguajes más próximos al procesador, como el 
      Ensamblador, a los que se llama lenguajes de Bajo Nivel. Cuanto más "Alto" 
      programemos, más control perderemos sobre nuestro programa, y esto es un 
      grave problema.</B></P>
      <P><B>Supongamos un programa, escrito en Alto Nivel, que pinta la frase 
      "HOLA MUNDO" en pantalla. ¿ Qué pasos se siguen hasta que realmente se 
      pinta la frase?. </B></P>
      <P><B>Nuestro programa debe de residir en un fichero, al que se denomina 
      fichero fuente, en el que aparece la sentencia para pintar la frase. Este 
      fichero no es entendible por el procesador, sólo es un conjunto de 
      caracteres, mu diferente del conjunto de 0 y 1 que necesita para trabajar. 
      Es aquí donde entra el compilador, transforma el fichero fuente en un 
      fichero intermedio, también llamado fichero objeto. En esta transformación 
      se comprueba la sintaxis de las sentencias ( falta el punto y coma) y la 
      semántica (has pasado un entero cuando se esperaba un real). El compilador 
      realiza entonces una fase de linkado para reunir los distintos ficheros 
      objeto que conforman nuestro programa final (aunque tengamos un único 
      fichero fuente). En esta fase se determinan el mapeo final del program en 
      memoria (que dirección de memoria va a tener cada instrucción del conjunto 
      de ficheros objeto). Tras la fase de linkado, el programa final se 
      encuentra en un lenguaje llamado pseudocódigo, mu sencillote. Aquí se 
      pueden tomar 3 vías. </B></P>
      <P><B><I>Primera:</I> Dejar el programa como está, y que otros pogramas o 
      librerías (como la vbrun500.dll de Visual Basic) lo traduzcan (lo 
      interpreten) a sentencias entendibles por el porcesador.</B></P>
      <P><B>Segunda: Transformar el pseudocódigo a un lenguaje de Bajo Nivel 
      como el ensamblador. En tal caso, se necesitará un compilador de 
      ensamblador para que el programa pueda ser ejecutado. OJO, el ensamblador 
      no es entendible por el tonto procesador que sólo ve unos y ceros, son dos 
      cosas distintas.</B></P>
      <P><B><I>Tecera: </I>La más común, transformar directamente de 
      pseudocódigo a ejecutable </B></P>
      <P><B>Un fichero ejecutable consta de unos y ceros (o de números en hexa, 
      según se mire) ordenados de una forma especial; ordenados en 
      instrucciones: Los 3 primeros números son el tipo de instrucción, los 4 
      siguientes el operando1, el siguiente el operador...Cada instrucción es 
      depiezada dentro del procesador y dan a lugar a la ejecución de un 
      conjunto de programas presenten dentro del procesador, son las 
      microrutinas. Estas microrutinas son las encargadas de bloquear buses, 
      activar multiplexores, dar tensión a un transistor o no, pa enterndernos. 
      Accionando correctamente buses, multiplexires... se pintará relamete la 
      frase en pantalla.</B></P>
      <P><B>Bien, esto es todo. </B></P>
      <P><B><FONT color=#00ff00>Mu bien y esto pa que coño me sirve.</FONT> 
      </B></P>
      <P><B>Existe una correspondencia directa entre lenguaje ensablador y 
      programa ejecutable. Gracias a un desensamblador (W32DASM, IDA PRO), a 
      partir de un ejecutable podemos obtener el programa el lenguaje ensablador 
      sin disponer del fichero fuente. Un program en ensamblador puede ser 
      fácilmente entendido por los humanos (o eso dicen algunos). Esto nos da un 
      poder tremendo a los crackers. Podemos saber como funciona un programa sin 
      necesitar del programa original. Y lo que es má aún, independientemente 
      del lenguaje de Alto Nivel. Todos los lenguajestienen que pasar a 
      ejecutable de alguna u otra forma, y es aquí cuando usamos nuestro 
      desensamblador y extraer su listado en ensablador. Da igual que programa 
      esté hecho en Pascal, O C++, lo entederemos igualmente ya que leeremos 
      ensamblador.</B></P>
    <TD></TD></TR></TBODY></TABLE><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00><FONT color=#00ff00>EL LISTADO MUERTO</FONT> 
      </FONT></B></P>
      <P><B><FONT color=#00ff00></FONT>La idea es sencilla. Cojemos nuestro 
      desensamblador favorito y se lo pasamos al objetivo. Obtendremos un 
      listado en ensamblador de nuestro programa a crackear. La técnica crack se 
      llama Listado muerto porque entenderemos y manejaremos el programa con 
      este listado, sin tener que ejecutarlo, con el programa muerto. A 
      diferencia de cuando lanzamos el SoftIce y entendemos el programa cuando 
      se está ejecuntandose, cuando "vive". </B></P>
      <P><B>Hay tre ventajas fundaentales para utilizar el Listado 
      Muerto.</B></P>
      <P><B>- Podemos seguir el programa fácilmemte de atrás hacia adelante, 
      basta con pasar de página, no hace falta volver a ejecutatlo.</B></P>
      <P><B>- Es mucho más relajado imprimir y estudiar 4 páginas de código que 
      rastrear con el SoftIce. Este es uno de los consejos de +ORC.</B></P>
      <P><B>- Se descubren pequeños secretos, como rutinas inactivas.</B></P>
      <P><B>La paciencia y la tranquilidad son dos requisitos fundamentales en 
      un cracker. Es fácil perderte trazando con el SoftIce e imposible con el 
      Listado Muerto.</B></P>
      <P><B><FONT color=#00ff00></FONT><FONT color=#00ff00>Manos a la 
      Obra</FONT></B></P>
      <P><B>Una vez desensamblado el objetivo, la idea es buscar cadenas de 
      texto interesantes, como "unregistered", "expired", "congratulations" y 
      mirar al rededor de estas cadenas buscando un salto mágico. Las palabras 
      en concreto dependen del programa y son las que aparecen para recordarte 
      que aún no te has registrado. </B></P>
    <TD></TD></TR></TBODY></TABLE><BR><BR>
<TABLE bgColor=#000000 border=4>
  <TBODY>
  <TR>
    <TD align=left vAlign=top>
      <P><B><FONT color=#00ff00>CÓMO CRACKEAR UEDIT 5.0</FONT> </B></P>
      <P><B>Objetivo: Uedit 5.0. <BR>Versión: 5.0 3/7/97 <BR>Nombre del 
      ejecutable: uedit32.exe <BR>Website: <A 
      name=http://www.uedit.com>http://www.uedit.com</A> <BR>Tamaño del 
      ejecutable: 812.514 bytes. <BR>Tipo de protección: Por número de serie y 
      temporal. <BR>Dificultad: Medio. <BR>Tiempo de crackeo: 5 minutos. 
      <BR>Herramientas: W32dasm8.X, SoftIce. </B></P>
      <P><B>Siguiendo la recomendación del maestro +ORC, continuamos con el 
      crack a nuestras herramientas de trabajo. En este caso nos encontramos 
      ante un excelente editor hexadecimal, vital para nuestros negocios 
      :-)</B></P>
      <P><B>Instalemos el programa, ejecutémoslo y veamos lo que nos 
      encontramos. ARRJJ!!, una horrible ventana nos dice que tenemos 45 diás 
      para registranos. Además tiene un bonito botón "Enter Authorization Code". 
      Pulsemos y veamos. Un típico nombre de usario y número de serie (al que le 
      llamaré passwod o pass). Si pulsamos cuaquier guarrada en ambos, sorpresa, 
      ningúm mensaje advirtiendo del error, ningún pitido (recordais el capítulo 
      I), nada excepto una ventana de mensaje que dice que hace falta cerrar el 
      programa para validar el código. ¿Habrá leido Ian D. Mead las lecciones de 
      Estado+Porcino?. Bien, ¿por donde atacar?. No tenemos nada que nos indique 
      que nos hemos equivocado. ¿Que tal si usamos el Listado Muerto 
      amiguitos?</B></P>
      <P><B>Una vez desensablado el programa y dentro del W32dasm pulsemos el 
      botón de Strn Ref (el boton que está al lado del botón de impresora) para 
      ver las cadenas de caracteres que aparecen en el nuetro objetivo. Que 
      vemos, que casualidad , tenemos la frase "Thank you fot supporting 
      Shareware" , hagamos doble click y veamos donde aparecemos: </B></P>
      <P><B>*<FONT size=-1> Referenced by a (U)nconditional or (C)onditional 
      Jump at Address: |:00401B77(C) | </FONT></B></P>
      <P><B><FONT size=-1>:00401B7D 83FB09 cmp ebx, 00000009 </FONT></B></P>
      <P><B><FONT size=-1>:00401B80 7504 jne 00401B86 </FONT></B></P>
      <P><B><FONT size=-1>:00401B82 C645EC20 mov [ebp-14], 20 * <FONT 
      size=-1>Referenced by a (U)nconditional or (C)onditional Jump at 
      </FONT></FONT></B></P>
      <P><B><FONT size=-1>:00401B86 8D45C8 lea eax, dword ptr [ebp-38] 
      </FONT></B></P>
      <P><B><FONT size=-1>* Possible Reference to String Resource ID=00010: " 
      Thank you for supporting Shareware." | </FONT></B></P>
      <P><B><FONT size=-1>:00401B89 6A0A push 0000000A </FONT></B></P>
      <P><B>En :00401B89 tenemos una referencia a la cadena que nos interesa. 
      Cada frase del programa tiene asociado un número, en este caso es el 
      0000000A y este número se les pasa al las rutinas que tienen que imprimir 
      los mensajes. La forma tradicional de pasarle parámetros a una rutina es a 
      través la pila mediante push (como en :00401B89 ). Los parámetros se pasan 
      empezando por el último, es lo que se llama paso de parámetros mediate el 
      modelo de PASCAL, existen otros modelos, pero son poco utilizados.</B></P>
      <P><B>¿Estamos en el camino adecuado¿, nop, ya que el número de nuestra 
      frase, el 0000000A (en es número 10 en decimal) es muy utilizado en 
      cualquier programa y cada vez que aparezca, el desensamblador pensará que 
      se está haciendo referencia a nuestra frase. Bien pensemos un poco. 
      </B></P>
      <P><B>Nuestro programa está limitado por 45 días de uso, pasado ese 
      tiempo, lo normal es que nos aparezca una frase deciendo algo así como 
      "Evaluation time expired". Busquemos (Con el botón de la linterna ) la 
      palabra expired pasada a una rutina mediante push a ver que 
      encontramos.</B></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:043F7D3 E8375DFCFF call 0040550F </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7D8 391DDC0C4A00 cmp dword ptr [004A0CDC], ebx 
      </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7DE 758A jne 0043F76A </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7E0 8D4D10 lea ecx, dword ptr [ebp+10] 
      </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7E3 E829C00100 call 0045B811 </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7E8 8D4D14 lea ecx, dword ptr [ebp+14] 
      </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7EB C645FC01 mov [ebp-04], 01 </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7EF E81DC00100 call 0045B811 </FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" size=-1>* 
      Possible Reference to String Resource ID=00068: "UltraEdit 45 Day 
      Evaluation time expired!!!!" |</FONT></FONT></B></FONT></P>
      <P><FONT size=-1><B><FONT face="Courier New"><FONT face="" 
      size=-1>:0043F7F4 6A44 push 00000044</FONT></FONT> </B></FONT></P>
      <P><B>BINGO. No sentís el código, no percibis como estamos en el camino 
      correcto.</B></P>
      <P><B>Si, tenemos en :0043F7F4 un push con el número asociado a la frase 
      que buscamos y justo en :0043F7DE un salto a 0043F76A que evita imprimir 
      el mesaje, pero el punto clave es ver la comprobación del salto en 
      :0043F7D8. Se comprueba si el contenido de EBX es igual a una dirección 
      fija de memoria la [004A0CDC]. Las direcciones fijas son las típicas 
      variables globales tan mal utilizadas en los programas. Tenemos una 
      variable global que controla la aparición de un mensaje de error. En algún 
      punto del programa debe de inicializarse [004A0CDC] con un valor ,si 
      localizamos este trozo de código, estaremos en plena rutina de 
      comprobación. ¿Facil, verdad?</B></P>
      <P><B>Busquemos [004A0CDC] y veamos quien la inicializa, sólo nos 
      interesan las sentencias que inicializen la variable, no las sentencias 
      que comprueban su valor. Normalmente se inicializa por defecto a un valor 
      de error (indicando que no estamos registrados) y se inicializa 
      corectamente cuando nos registrmemos. Conforme aparecen occurencias de 
      nuestra variable glabal sabemos que estamos en el buen camino porque 
      siempre está rodeada de mensajes de error o de felicitación.</B></P>
      <P><B>Buscando [004A0CDC] encontramos las siguientes sentencias que 
      modifican la variable (el resto de apariciones son comprobaciones del 
      valor)</B></P>
      <P><B><FONT size=-1>:00405541 893DDC0C4A00 mov dword ptr [004A0CDC], 
      edi</FONT></B></P>
      <P><B><FONT size=-1>:004056A3 891DDC0C4A00 mov dword ptr [004A0CDC], 
      ebx</FONT></B></P>
      <P><B><FONT size=-1>:004057D4 8325DC0C4A0000 and dword ptr [004A0CDC], 
      00000000</FONT></B></P>
      <P><B><FONT size=-1>:00426924 891DDC0C4A00 mov dword ptr [004A0CDC], 
      ebx</FONT></B></P>
      <P><B><FONT size=-1>:0043F684 C705DC0C4A0001000000 mov dword ptr 
      [004A0CDC], 00000001</FONT></B></P>
      <P><B>Que tenemos aquí. Parece lógico pensar que en :004057D4 tenemos la 
      incialización por defecto, ya que un AND con ceros da cero. La sentencia 
      contraria la tenemos en :0043F684 que mueve 1 a la variable, esto sin duda 
      indica que nos hemos registrado. También podría ser al revés, cero 
      registrado, uno no registrado, pero este no es el caso. Basta ejecutar el 
      Softice y poner bpr 004A0CDC 004A0CDC rw , la primera modificación debe 
      ser la asignación por defecto, en este caso la :004057D4. Por tanto solo 
      debemos centrarnos en la asignación a uno :0043F684, olvidando el resto de 
      asignaciones. Esto es un axioma fundamental ante la duda, elige siempre la 
      solución más sencilla. Bien, veamos que hay entorno a la :0043F684 
</B></P>
      <P><FONT size=-1><B>:0043F65C E89A560300 call 00474CFB </B></FONT></P>
      <P><FONT size=-1><B>:0043F661 8B7804 mov edi, dword ptr [eax+04] 
      </B></FONT></P>
      <P><FONT size=-1><B>:0043F664 8B4514 mov eax, dword ptr [ebp+14] 
      </B></FONT></P>
      <P><FONT size=-1><B>:0043F667 48 dec eax </B></FONT></P>
      <P><FONT size=-1><B>:0043F668 7478 je 0043F6E2 </B></FONT></P>
      <P><FONT size=-1><B>:0043F66A 48 dec eax </B></FONT></P>
      <P><FONT size=-1><B>:0043F66B 0F85F9000000 jne 0043F76A </B></FONT></P>
      <P><FONT size=-1><B>:0043F671 391DDC0C4A00 cmp dword ptr [004A0CDC], ebx 
      </B></FONT></P>
      <P><FONT size=-1><B>:0043F677 0F85DA010000 jne 0043F857 </B></FONT></P>
      <P><FONT size=-1><B>:0043F67D 833DBC024A0000 cmp dword ptr [004A02BC], 
      00000000 </B></FONT></P>
      <P><FONT size=-1><B>:0043F684 C705DC0C4A0001000000 mov dword ptr 
      [004A0CDC], 00000001</B></FONT></P>
      <P><B>Tenemos diversos saltos que evitan nuestra asignación a uno. El 
      primer salto, sestá en <FONT color=#ffff00>:0043F668 7478 je 0043F6E2 
      </FONT>que tal si lo cambiamos por <FONT color=#ff0000>EB1A jmp 
      43F684<FONT color=#ffffff>. Osea, siempre saltamos a 43F684 evitando las 
      comprobaciones de :0043F66B y :0043F677.El código EB es la instrucción de 
      salto incondincional JMP, 1A es el número de bytes desde la sentencia 
      condicional hasta la sentencia donde queremos saltar. Fácil, 
      ¿verdad?.</FONT></FONT></B></P>
      <P><B><FONT color=#ff0000><FONT color=#ffffff>Perfecto, rula. Basta con 
      buscar en el ejecutable uedit32 la secuencia 8B451448747848 y cambiarla 
      por 8B451448EB1A48. Pero hay un peque problema, el crack funciona pero no 
      tenemos un número de serie correcto. En principio basta, pero pensando un 
      poco podremos sacar nuestro propio número de Serie. ¿ Qué se os 
      ocurre?</FONT></FONT></B></P>
      <P><FONT color=#ff0000><FONT color=#ffffff><B>Sip, exactamante,¿ que tal 
      si le seguimos la pista a nuestro número de serie basura y vemos con quién 
      se comparará? . La pregunata es, donde coloco un bpx para pararme justo 
      antes de que se compruebe mi número de serie. La respuesta es sencilla, en 
      :43F618 (echarle un vistazo al listado muerto) comienza la rutina en la 
      que se asigna a 1 nuestra variable glabal. Este puede ser un buen 
      comienzo. Abrimos el Softice con el uedit, ponemos nuestro nombre 
      Estado+Porcino y un número basura 1212121212121212 . Cerramos el uedit y 
      lanzamos de nuevo el SoftIce poniendo la sentencia</B> <I>bpx 
      43F618</I><B>. Aparecemos en :43F618, ahora es el momento de buscan 
      nuestro número de serie con </B><I>s 30:00 l ffffffff ´12121212´ </I><B>lo 
      encontramos es :942F9C (esta direcciónpuede cambiar en tu ordenador). 
      Borramos el punto de ruptura anterior con</B><I> bc 0 </I><B>y creamos uno 
      nuevo con la dirección donde está nuestra password con </B>b<I>pr 942F9C 
      942F9C+f rw </I><B>seguimos adelante con </B><I>Crtl+D </I><B>para ver 
      quien caen en buestra trampa. Aparecemos en :40B73A con varios movsd , 
      nuestra password se está copiando en otro sitio. La sentencia movsd, copia 
      caracteres de ees:esi a ees:edi. Pongamos en el SoftIce</B><I> d ees:edi 
      </I><B>para ver</B><I> </I><B>como realmente se va a copiar, además 
      pongamos otro punto de ruptura en la nueva posición de nuestra 
      password</B> <B>con </B><I>bpr ees:edi ees:edi+f rw 
      </I><B><I>.</I>Curiosamente, si nos movemos un poco con los cursores por 
      ees:edi aparecen las passwords correctas, pero todavía no es el momento. 
      Lancemos de nuevo el SoftIce con </B><I>Crtl+D </I><B>y aparecemos en 
      :444FOE ,aquí encontramos una pequeña comprobación, en ecx tenemos nuestra 
      pass (para comprobarlo basta con poner</B><I> d ecx</I><B>) y en edx 
      apuntamos a una zona de nuestro nombre, concretamente a "tado+Porcino". 
      Esto no es exactamente lo qu buscamos, así que sigamos adelante con 
      </B><I>Crtl+D </I><B>y aparecemos en :444EBO con una comprobación entre 
      edx y ecx a través de al. Curiosamente edx apunta a nuestra pass y ecx 
      apunta a<FONT color=#ffff00> Y2+cHdcBd6=DBC/P </FONT>este churro es la 
      pass correcta, si seguimos con </B><I>Crtl+D </I><B>aparecemos en el mismo 
      sitio con edx apuntando a nuestra pass y ecx apunta a</B><FONT 
      color=#ff0000><I> </I><B><FONT color=#ff0080>JWKTUUTH02166710 <FONT 
      color=#ffffff>otra pass correcta</FONT><FONT color=#ffffff>. A lo largo de 
      la evolución del programa desde sus primeras versiones, se ha cambiado 2 
      veces de generador de pass por cuestiones de seguridad, ¡qué estúpidos!. 
      Por eso la doble comprobación, ver si nuestra pass es del antiguo 
      generador o del nuevo.</FONT></FONT></B></FONT></FONT></FONT></P>
      <P><FONT color=#ff0000><FONT color=#ffffff><FONT color=#ff0000><B><FONT 
      color=#ff0080><FONT color=#ffffff>Eso es todo por ahora, no seais unos 
      descerebrados y utilicéis mi pass, buscad la vuestra, es mu 
      sencillote.</FONT></FONT></B></FONT></FONT></FONT> </P><B>Espero vuestras 
      opiniones, sugerencias y ensayos en <A 
      href="mailto:estadoporcino@hotmail.com">estadoporcino@hotmail.com</A></B> 
      <BR><B>En breve analizaremos tipos de protecciones mucho más 
      interesantes.</B><BR>
      <P><B>Recordad bebed de la fuente, buscad a <FONT 
      color=#00ff00>+ORC</FONT> en la red.</B> <BR><BR>
</BODY></HTML>
